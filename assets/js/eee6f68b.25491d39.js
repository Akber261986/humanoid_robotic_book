"use strict";(globalThis.webpackChunkhumanoid_robotic_book=globalThis.webpackChunkhumanoid_robotic_book||[]).push([[350],{5127:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>t,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var s=i(4848),o=i(8453);const r={},t="Gazebo Simulation Environment",l={id:"module2/gazebo_environment",title:"Gazebo Simulation Environment",description:"Overview",source:"@site/docs/module2/gazebo_environment.md",sourceDirName:"module2",slug:"/module2/gazebo_environment",permalink:"/humanoid_robotic_book/docs/module2/gazebo_environment",draft:!1,unlisted:!1,editUrl:"https://github.com/Akber261986/humanoid_robotic_book/edit/main/docs/module2/gazebo_environment.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"ROS 2 Setup for Robotics",permalink:"/humanoid_robotic_book/docs/module2/ros2_setup"},next:{title:"NVIDIA Isaac Sim Introduction",permalink:"/humanoid_robotic_book/docs/module2/isaac_sim_intro"}},a={},c=[{value:"Overview",id:"overview",level:2},{value:"What is Gazebo?",id:"what-is-gazebo",level:2},{value:"Key Features",id:"key-features",level:2},{value:"Physics Simulation",id:"physics-simulation",level:3},{value:"Sensor Simulation",id:"sensor-simulation",level:3},{value:"Rendering and Visualization",id:"rendering-and-visualization",level:3},{value:"Installing Gazebo",id:"installing-gazebo",level:2},{value:"System Requirements",id:"system-requirements",level:3},{value:"Installation Steps",id:"installation-steps",level:3},{value:"1. Update package list",id:"1-update-package-list",level:4},{value:"2. Install Gazebo Garden (recommended version for ROS 2 Humble)",id:"2-install-gazebo-garden-recommended-version-for-ros-2-humble",level:4},{value:"3. Install Gazebo ROS packages",id:"3-install-gazebo-ros-packages",level:4},{value:"4. Install additional tools",id:"4-install-additional-tools",level:4},{value:"Verification",id:"verification",level:3},{value:"Gazebo World Format",id:"gazebo-world-format",level:2},{value:"World Files",id:"world-files",level:3},{value:"Robot Description in URDF",id:"robot-description-in-urdf",level:2},{value:"Gazebo ROS Integration",id:"gazebo-ros-integration",level:2},{value:"ROS 2 Control Interface",id:"ros-2-control-interface",level:3},{value:"Common Topics",id:"common-topics",level:3},{value:"Physics Configuration",id:"physics-configuration",level:2},{value:"Physics Engines",id:"physics-engines",level:3},{value:"Quality of Service Settings",id:"quality-of-service-settings",level:3},{value:"Simulation Best Practices",id:"simulation-best-practices",level:2},{value:"1. Model Complexity",id:"1-model-complexity",level:3},{value:"2. Physics Parameters",id:"2-physics-parameters",level:3},{value:"3. Sensor Configuration",id:"3-sensor-configuration",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"Performance Issues",id:"performance-issues",level:3},{value:"Physics Instability",id:"physics-instability",level:3},{value:"ROS Communication Issues",id:"ros-communication-issues",level:3},{value:"Example: Launching a Humanoid Robot in Gazebo",id:"example-launching-a-humanoid-robot-in-gazebo",level:2},{value:"1. Create launch file (<code>launch/humanoid_gazebo.launch.py</code>)",id:"1-create-launch-file-launchhumanoid_gazebolaunchpy",level:3},{value:"2. Robot state publisher",id:"2-robot-state-publisher",level:3},{value:"Practical Exercise: ROS 2 + Gazebo Movement Example",id:"practical-exercise-ros-2--gazebo-movement-example",level:2},{value:"Verification Steps",id:"verification-steps",level:2},{value:"Advanced Features",id:"advanced-features",level:2},{value:"Plugins",id:"plugins",level:3},{value:"Integration with ROS 2 Control",id:"integration-with-ros-2-control",level:3},{value:"References",id:"references",level:2},{value:"References",id:"references-1",level:2},{value:"Additional Resources",id:"additional-resources",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"gazebo-simulation-environment",children:"Gazebo Simulation Environment"}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"Gazebo is a powerful open-source 3D robotics simulator that provides realistic physics simulation, high-quality graphics, and convenient interfaces for creating and testing robot designs. This module covers the setup and usage of Gazebo for humanoid robotics simulation."}),"\n",(0,s.jsx)(n.h2,{id:"what-is-gazebo",children:"What is Gazebo?"}),"\n",(0,s.jsx)(n.p,{children:"Gazebo is a 3D dynamic simulator with the ability to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Accurately and efficiently simulate populations of robots in complex indoor and outdoor environments"}),"\n",(0,s.jsx)(n.li,{children:"Provide realistic rendering of environments using OGRE (Object-Oriented Graphics Rendering Engine)"}),"\n",(0,s.jsx)(n.li,{children:"Simulate various sensors including cameras, LiDAR, IMU, and more"}),"\n",(0,s.jsx)(n.li,{children:"Integrate with ROS/ROS 2 for robot control and data exchange"}),"\n",(0,s.jsx)(n.li,{children:"Support for multiple physics engines (ODE, Bullet, Simbody)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"key-features",children:"Key Features"}),"\n",(0,s.jsx)(n.h3,{id:"physics-simulation",children:"Physics Simulation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Realistic physics"}),": Accurate simulation of rigid body dynamics"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Contact simulation"}),": Realistic contact forces and friction"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multi-body dynamics"}),": Support for complex articulated robots"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fluid simulation"}),": Basic fluid dynamics for underwater robots"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"sensor-simulation",children:"Sensor Simulation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Camera sensors"}),": RGB, depth, and stereo cameras"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Range sensors"}),": LiDAR, sonar, and infrared sensors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Inertial sensors"}),": IMU and accelerometer simulation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Force/torque sensors"}),": Joint force and torque measurements"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"GPS simulation"}),": Global positioning system simulation"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"rendering-and-visualization",children:"Rendering and Visualization"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"High-quality graphics"}),": Realistic rendering using OGRE"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multiple viewports"}),": Different camera angles and perspectives"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dynamic lighting"}),": Realistic lighting effects"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Texture mapping"}),": Detailed surface textures"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"installing-gazebo",children:"Installing Gazebo"}),"\n",(0,s.jsx)(n.h3,{id:"system-requirements",children:"System Requirements"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Operating System"}),": Ubuntu 20.04 or 22.04 (recommended)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Graphics"}),": OpenGL 2.1+ compatible GPU"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"RAM"}),": Minimum 4GB, 8GB+ recommended"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Disk Space"}),": At least 2GB for basic installation"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"installation-steps",children:"Installation Steps"}),"\n",(0,s.jsx)(n.h4,{id:"1-update-package-list",children:"1. Update package list"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"sudo apt update\n"})}),"\n",(0,s.jsx)(n.h4,{id:"2-install-gazebo-garden-recommended-version-for-ros-2-humble",children:"2. Install Gazebo Garden (recommended version for ROS 2 Humble)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"sudo apt install gazebo\n"})}),"\n",(0,s.jsx)(n.h4,{id:"3-install-gazebo-ros-packages",children:"3. Install Gazebo ROS packages"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"sudo apt install ros-humble-gazebo-ros-pkgs ros-humble-gazebo-plugins ros-humble-gazebo-dev\n"})}),"\n",(0,s.jsx)(n.h4,{id:"4-install-additional-tools",children:"4. Install additional tools"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"sudo apt install ros-humble-joint-state-publisher-gui ros-humble-robot-state-publisher\n"})}),"\n",(0,s.jsx)(n.h3,{id:"verification",children:"Verification"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"gazebo --version\n# Should show Gazebo version information\n"})}),"\n",(0,s.jsx)(n.h2,{id:"gazebo-world-format",children:"Gazebo World Format"}),"\n",(0,s.jsx)(n.h3,{id:"world-files",children:"World Files"}),"\n",(0,s.jsx)(n.p,{children:"Gazebo uses SDF (Simulation Description Format) to define simulation environments:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="default">\n    \x3c!-- Include a model from the model database --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- Lighting --\x3e\n    <include>\n      <uri>model://sun</uri>\n    </include>\n\n    \x3c!-- Custom robot --\x3e\n    <model name="my_robot">\n      <pose>0 0 0.5 0 0 0</pose>\n      <link name="chassis">\n        <collision name="collision">\n          <geometry>\n            <box>\n              <size>1.0 0.5 0.2</size>\n            </box>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <box>\n              <size>1.0 0.5 0.2</size>\n            </box>\n          </geometry>\n        </visual>\n      </link>\n    </model>\n  </world>\n</sdf>\n'})}),"\n",(0,s.jsx)(n.h2,{id:"robot-description-in-urdf",children:"Robot Description in URDF"}),"\n",(0,s.jsx)(n.p,{children:"For humanoid robots, Gazebo uses URDF (Unified Robot Description Format) with Gazebo-specific extensions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="humanoid_robot" xmlns:xacro="http://www.ros.org/wiki/xacro">\n  \x3c!-- Base link --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <cylinder length="0.2" radius="0.1"/>\n      </geometry>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder length="0.2" radius="0.1"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1.0"/>\n      <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.1"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Gazebo material --\x3e\n  <gazebo reference="base_link">\n    <material>Gazebo/Blue</material>\n  </gazebo>\n\n  \x3c!-- Joint between base and torso --\x3e\n  <joint name="base_to_torso" type="fixed">\n    <parent link="base_link"/>\n    <child link="torso"/>\n    <origin xyz="0 0 0.1" rpy="0 0 0"/>\n  </joint>\n\n  <link name="torso">\n    <visual>\n      <geometry>\n        <box size="0.3 0.2 0.5"/>\n      </geometry>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.3 0.2 0.5"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="2.0"/>\n      <inertia ixx="0.2" ixy="0.0" ixz="0.0" iyy="0.2" iyz="0.0" izz="0.2"/>\n    </inertial>\n  </link>\n</robot>\n'})}),"\n",(0,s.jsx)(n.h2,{id:"gazebo-ros-integration",children:"Gazebo ROS Integration"}),"\n",(0,s.jsx)(n.h3,{id:"ros-2-control-interface",children:"ROS 2 Control Interface"}),"\n",(0,s.jsx)(n.p,{children:"Gazebo integrates with ROS 2 through the ros_gz bridge:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'# Launch a robot in Gazebo\nros2 launch my_robot_gazebo my_robot_world.launch.py\n\n# Check available topics\nros2 topic list | grep -E "(joint|cmd|imu)"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"common-topics",children:"Common Topics"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"/joint_states"}),": Current joint positions, velocities, and efforts"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"/cmd_vel"}),": Velocity commands for mobile robots"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"/camera/image_raw"}),": Camera image data"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"/imu"}),": Inertial measurement unit data"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"/tf"}),": Transform data between coordinate frames"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"physics-configuration",children:"Physics Configuration"}),"\n",(0,s.jsx)(n.h3,{id:"physics-engines",children:"Physics Engines"}),"\n",(0,s.jsx)(n.p,{children:"Gazebo supports multiple physics engines:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ODE (Open Dynamics Engine)"}),": Default, good balance of speed and accuracy"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Bullet"}),": Faster simulation, good for real-time applications"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Simbody"}),": More accurate for complex articulated systems"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"quality-of-service-settings",children:"Quality of Service Settings"}),"\n",(0,s.jsx)(n.p,{children:"In simulation files, you can configure physics parameters:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<physics type="ode">\n  <max_step_size>0.001</max_step_size>  \x3c!-- Simulation time step --\x3e\n  <real_time_factor>1.0</real_time_factor>  \x3c!-- Real-time vs simulation speed --\x3e\n  <real_time_update_rate>1000.0</real_time_update_rate>  \x3c!-- Hz --\x3e\n  <gravity>0 0 -9.8</gravity>  \x3c!-- Gravity vector --\x3e\n</physics>\n'})}),"\n",(0,s.jsx)(n.h2,{id:"simulation-best-practices",children:"Simulation Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"1-model-complexity",children:"1. Model Complexity"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Start with simplified models for faster simulation"}),"\n",(0,s.jsx)(n.li,{children:"Add detail gradually as needed"}),"\n",(0,s.jsx)(n.li,{children:"Balance visual fidelity with simulation performance"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"2-physics-parameters",children:"2. Physics Parameters"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Tune damping and friction coefficients for realistic behavior"}),"\n",(0,s.jsx)(n.li,{children:"Use appropriate mass and inertia values"}),"\n",(0,s.jsx)(n.li,{children:"Consider the impact of time step on stability"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"3-sensor-configuration",children:"3. Sensor Configuration"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Configure sensor noise parameters to match real sensors"}),"\n",(0,s.jsx)(n.li,{children:"Set appropriate update rates for different sensors"}),"\n",(0,s.jsx)(n.li,{children:"Consider field of view and range limitations"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,s.jsx)(n.h3,{id:"performance-issues",children:"Performance Issues"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Reduce visual complexity\ngz sim -r --minimal_gui world_name.sdf\n\n# Lower physics update rate in world file\n<max_step_size>0.01</max_step_size>\n"})}),"\n",(0,s.jsx)(n.h3,{id:"physics-instability",children:"Physics Instability"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Increase solver iterations"}),"\n",(0,s.jsx)(n.li,{children:"Reduce time step size"}),"\n",(0,s.jsx)(n.li,{children:"Check mass and inertia values"}),"\n",(0,s.jsx)(n.li,{children:"Verify joint limits and stiffness"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"ros-communication-issues",children:"ROS Communication Issues"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Check bridge status\nros2 run ros_gz_bridge parameter_bridge --ros-args --log-level info\n\n# Verify topic connections\nros2 topic info /joint_states\n"})}),"\n",(0,s.jsx)(n.h2,{id:"example-launching-a-humanoid-robot-in-gazebo",children:"Example: Launching a Humanoid Robot in Gazebo"}),"\n",(0,s.jsx)(n.p,{children:"Here's a complete example of launching a humanoid robot in Gazebo with ROS 2:"}),"\n",(0,s.jsxs)(n.h3,{id:"1-create-launch-file-launchhumanoid_gazebolaunchpy",children:["1. Create launch file (",(0,s.jsx)(n.code,{children:"launch/humanoid_gazebo.launch.py"}),")"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\n\ndef generate_launch_description():\n    ld = LaunchDescription()\n\n    # Launch Gazebo with a world file\n    gazebo = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource([\n            PathJoinSubstitution([\n                FindPackageShare('gazebo_ros'),\n                'launch',\n                'gazebo.launch.py'\n            ])\n        ]),\n        launch_arguments={\n            'world': PathJoinSubstitution([\n                FindPackageShare('my_humanoid_description'),\n                'worlds',\n                'simple_room.sdf'\n            ])\n        }.items()\n    )\n\n    ld.add_action(gazebo)\n\n    # Spawn robot in Gazebo\n    spawn_entity = Node(\n        package='gazebo_ros',\n        executable='spawn_entity.py',\n        arguments=[\n            '-topic', 'robot_description',\n            '-entity', 'humanoid_robot',\n            '-x', '0.0',\n            '-y', '0.0',\n            '-z', '0.5'\n        ],\n        output='screen'\n    )\n\n    ld.add_action(spawn_entity)\n\n    return ld\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-robot-state-publisher",children:"2. Robot state publisher"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    return LaunchDescription([\n        Node(\n            package='robot_state_publisher',\n            executable='robot_state_publisher',\n            name='robot_state_publisher',\n            parameters=[\n                {'use_sim_time': True},\n                {'robot_description': open('path/to/robot.urdf').read()}\n            ]\n        )\n    ])\n"})}),"\n",(0,s.jsx)(n.h2,{id:"practical-exercise-ros-2--gazebo-movement-example",children:"Practical Exercise: ROS 2 + Gazebo Movement Example"}),"\n",(0,s.jsxs)(n.p,{children:["Let's look at a practical example that demonstrates robot movement in Gazebo using ROS 2. This example is available in the examples directory as ",(0,s.jsx)(n.code,{children:"basic_movement_ros2_gazebo.py"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist\nfrom nav_msgs.msg import Odometry\nimport math\nimport time\n\n\nclass BasicMovementController(Node):\n    \"\"\"\n    A simple controller that makes a robot move in a square pattern in Gazebo.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('basic_movement_controller')\n\n        # Create publisher for velocity commands\n        self.cmd_vel_pub = self.create_publisher(Twist, '/cmd_vel', 10)\n\n        # Create subscriber for odometry (to track robot position)\n        self.odom_sub = self.create_subscription(\n            Odometry,\n            '/odom',\n            self.odom_callback,\n            10\n        )\n\n        # Initialize variables to track robot state\n        self.current_x = 0.0\n        self.current_y = 0.0\n        self.current_yaw = 0.0  # Robot's orientation\n\n        # Movement parameters\n        self.linear_speed = 0.5  # m/s\n        self.angular_speed = 0.5  # rad/s\n        self.side_length = 1.0  # Length of each side of the square (meters)\n\n        # Movement state\n        self.movement_state = 0  # 0-7: 4 sides + 4 turns\n        self.state_start_time = self.get_clock().now()\n        self.state_duration = 0.0\n\n        # Create a timer for the control loop\n        self.timer = self.create_timer(0.1, self.control_loop)\n\n        self.get_logger().info('Basic Movement Controller initialized')\n\n    def odom_callback(self, msg):\n        \"\"\"\n        Callback function to update robot's position and orientation.\n        \"\"\"\n        # Extract position\n        self.current_x = msg.pose.pose.position.x\n        self.current_y = msg.pose.pose.position.y\n\n        # Extract orientation (convert quaternion to yaw)\n        orientation = msg.pose.pose.orientation\n        self.current_yaw = math.atan2(\n            2.0 * (orientation.w * orientation.z + orientation.x * orientation.y),\n            1.0 - 2.0 * (orientation.y * orientation.y + orientation.z * orientation.z)\n        )\n\n    def control_loop(self):\n        \"\"\"\n        Main control loop that determines the robot's movement based on state.\n        \"\"\"\n        msg = Twist()\n\n        # Calculate elapsed time in current state\n        current_time = self.get_clock().now()\n        elapsed_time = (current_time - self.state_start_time).nanoseconds / 1e9\n\n        if self.movement_state < 8:  # Only move for 8 states (square pattern)\n            if self.movement_state % 2 == 0:  # Moving forward\n                # Move forward for the length of a side\n                msg.linear.x = self.linear_speed\n                msg.angular.z = 0.0\n\n                # Check if we've moved enough distance\n                expected_duration = self.side_length / self.linear_speed\n                if elapsed_time >= expected_duration:\n                    self.movement_state += 1\n                    self.state_start_time = current_time\n                    self.get_logger().info(f'Turning: State {self.movement_state}')\n\n            else:  # Turning\n                # Turn 90 degrees\n                msg.linear.x = 0.0\n                msg.angular.z = self.angular_speed\n\n                # Check if we've turned 90 degrees (pi/2 radians)\n                expected_duration = (math.pi / 2) / self.angular_speed\n                if elapsed_time >= expected_duration:\n                    self.movement_state += 1\n                    self.state_start_time = current_time\n                    self.get_logger().info(f'Moving forward: State {self.movement_state}')\n\n        else:  # Stop after completing the square\n            msg.linear.x = 0.0\n            msg.angular.z = 0.0\n            self.get_logger().info('Movement completed. Robot stopped.')\n            self.timer.cancel()  # Stop the timer\n\n        # Publish the velocity command\n        self.cmd_vel_pub.publish(msg)\n\n        # Log current state\n        self.get_logger().info(\n            f'State: {self.movement_state}, '\n            f'Position: ({self.current_x:.2f}, {self.current_y:.2f}), '\n            f'Yaw: {math.degrees(self.current_yaw):.2f}\xb0'\n        )\n\n\ndef main(args=None):\n    \"\"\"\n    Main function to run the basic movement controller.\n    \"\"\"\n    rclpy.init(args=args)\n\n    # Create the controller node\n    controller = BasicMovementController()\n\n    try:\n        # Spin the node to process callbacks\n        rclpy.spin(controller)\n    except KeyboardInterrupt:\n        controller.get_logger().info('Interrupted by user')\n    finally:\n        # Clean up\n        controller.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"verification-steps",children:"Verification Steps"}),"\n",(0,s.jsx)(n.p,{children:"To verify your Gazebo and ROS 2 integration:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Installation Verification"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Check Gazebo installation\ngazebo --version\n\n# Check ROS 2 installation\nros2 topic list\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Basic Launch Test"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Create a simple URDF robot model"}),"\n",(0,s.jsx)(n.li,{children:"Launch Gazebo with the robot"}),"\n",(0,s.jsx)(n.li,{children:"Verify the robot appears in the simulation"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Control Verification"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Launch the movement example"}),"\n",(0,s.jsx)(n.li,{children:"Verify the robot moves as expected"}),"\n",(0,s.jsx)(n.li,{children:"Check that odometry data is published correctly"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Communication Check"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'# Verify ROS 2 topics are active\nros2 topic list | grep -E "(joint|cmd|odom)"\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Performance Verification"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Monitor simulation real-time factor (should be close to 1.0)"}),"\n",(0,s.jsx)(n.li,{children:"Check CPU and memory usage"}),"\n",(0,s.jsx)(n.li,{children:"Verify sensor data rates match expectations"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,s.jsx)(n.h3,{id:"plugins",children:"Plugins"}),"\n",(0,s.jsx)(n.p,{children:"Gazebo supports various plugins for extended functionality:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Controller plugins"}),": For robot control"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sensor plugins"}),": For custom sensor simulation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Model plugins"}),": For custom model behavior"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"World plugins"}),": For world-specific behavior"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"integration-with-ros-2-control",children:"Integration with ROS 2 Control"}),"\n",(0,s.jsx)(n.p,{children:"For advanced control, integrate with ros2_control:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<gazebo>\n  <plugin name="gazebo_ros2_control" filename="libgazebo_ros2_control.so">\n    <parameters>$(find-pkg-share my_robot_control)/config/my_robot_controllers.yaml</parameters>\n  </plugin>\n</gazebo>\n'})}),"\n",(0,s.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"http://gazebosim.org/",children:"Gazebo Documentation"})," - Official Gazebo documentation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"http://gazebosim.org/tutorials",children:"Gazebo Tutorials"})," - Step-by-step tutorials"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/gazebosim/ros_gz",children:"ROS 2 Gazebo Integration"})," - ROS 2 and Gazebo bridge"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/gazebosim/gazebo",children:"Gazebo GitHub"})," - Source code repository"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"references-1",children:"References"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"http://gazebosim.org/",children:"Gazebo Documentation"})," - Official Gazebo documentation (verified: official source)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"http://gazebosim.org/tutorials",children:"Gazebo Tutorials"})," - Step-by-step tutorials (verified: official source)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/gazebosim/ros_gz",children:"ROS 2 Gazebo Integration"})," - ROS 2 and Gazebo bridge (verified: official GitHub repository)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://www.openrobotics.org/",children:"Open Robotics"})," - Organization behind Gazebo (verified: official organization)"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"additional-resources",children:"Additional Resources"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://community.gazebosim.org/",children:"Gazebo Community"})," - Community forum"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://answers.gazebosim.org/",children:"Gazebo Q&A"})," - Question and answer site"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://www.openrobotics.org/",children:"Open Robotics"})," - Organization behind Gazebo"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>l});var s=i(6540);const o={},r=s.createContext(o);function t(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);